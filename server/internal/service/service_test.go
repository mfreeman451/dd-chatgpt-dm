package service

import (
	"context"
	"fmt"
	"github.com/mfreeman451/dd-chatgpt-dm/gen/game/v1/gamev1connect"
	playerv1 "github.com/mfreeman451/dd-chatgpt-dm/gen/player/v1"
	roomv1 "github.com/mfreeman451/dd-chatgpt-dm/gen/room/v1"
	"github.com/mfreeman451/dd-chatgpt-dm/server/pkg/db"
	myred "github.com/mfreeman451/dd-chatgpt-dm/server/pkg/db/cache"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"log"
	"testing"
)

type mockDB struct {
	player *playerv1.Player
	err    error
}

type mockRedis struct {
	roomState *roomv1.RoomState
	err       error
}

func (m *mockDB) ListPlayers(ctx context.Context) ([]*playerv1.Player, error) {
	//TODO implement me
	panic("implement me")
}

func (m *mockDB) GetPlayer(ctx context.Context, id string) (*playerv1.Player, error) {
	return &playerv1.Player{
		Id:   "123",
		Name: "Test Player",
	}, nil
}

func (m *mockDB) CreatePlayer(ctx context.Context, req *playerv1.CreatePlayerRequest) (string, error) {
	player := req.Player
	player.Id = "123"
	return player.Id, m.err
}

func (m *mockDB) UpdatePlayer(ctx context.Context, req *playerv1.UpdatePlayerRequest) error {
	return m.err
}

func (r *mockRedis) GetRoomState(roomID string) (*roomv1.RoomState, error) {
	// Return the mock room state
	return r.roomState, r.err
}

func (r *mockRedis) SetRoomState(roomID string, state *roomv1.RoomState) error {
	// Update the mock room state
	r.roomState = state
	return r.err
}

func TestCreatePlayer(t *testing.T) {

	mockDB := db.NewMockDB()
	mockRedis := myred.NewMockRedis()
	// setup a message.Publisher to use in the service

	srv := NewService(mockDB, mockRedis, publisher)

	// create a random name

	req := &playerv1.CreatePlayerRequest{
		Player: &playerv1.Player{
			Name: "John",
		},
	}

	resp, err := srv.CreatePlayer(context.Background(), req)

	if err != nil {
		t.Fatal(err)
	}

	// Create the expected response with all fields set to default values
	want := &playerv1.Player{
		Id:           "123", // Since the ID is generated by the server, set it to the expected value
		Name:         "John",
		DeathSaves:   &playerv1.DeathSaves{},
		RacialTraits: &playerv1.RacialTraits{},
		// Add other fields as needed with their respective default values
	}

	fmt.Print("resp.Player: ", resp.Player, "\n")
	fmt.Print("want: ", want, "\n")

	// Compare the Id field as strings
	if resp.Player.Id != want.Id {
		t.Errorf("unexpected player id: %q, want id: %q", resp.Player.Id, want.Id)
	}

	if resp.Player.Name != want.Name {
		t.Errorf("unexpected player name: %q, want name: %q", resp.Player.Name, want.Name)
	}

	// Add other comparisons for other fields as needed

	// ...
}

func TestCreatePlayerDBError(t *testing.T) {

	// Create a mock DB that returns an error
	mockDb := db.NewMockDB()
	mockRedis := myred.NewMockRedis()

	srv := NewService(mockDb, mockRedis)

	// Call the method
	req := &playerv1.CreatePlayerRequest{
		Player: &playerv1.Player{
			Name: "John",
		},
	}
	resp, err := srv.CreatePlayer(context.Background(), req)

	// Assert we got the expected error
	if err == nil {
		t.Fatal("Expected error but got nil")
	}

	grpcErr, ok := status.FromError(err)
	if !ok {
		t.Fatal("Expected gRPC error as result")
	}

	if grpcErr.Code() != codes.Internal {
		t.Errorf("Expected Internal error code but got %v", grpcErr.Code())
	}

	if grpcErr.Message() != "failed to create player: db error" {
		t.Errorf("Unexpected error message %q", grpcErr.Message())
	}

	// Assert response is nil
	if resp != nil {
		t.Error("Expected nil response on error")
	}
}

func TestListPlayers(t *testing.T) {
	// Start the gRPC server in a separate goroutine
	/*
		go func() {
			if err := startGRPCServer(); err != nil {
				log.Fatalf("Failed to start gRPC server: %v", err)
			}
		}()
	*/

	// Set up a connection to the gRPC server
	conn, err := grpc.Dial("localhost:8080", grpc.WithInsecure())
	if err != nil {
		t.Fatalf("Failed to dial server: %v", err)
	}
	defer func(conn *grpc.ClientConn) {
		err := conn.Close()
		if err != nil {
			t.Errorf("Failed to close connection: %v", err)
		}
	}(conn)

	// Create a gRPC client
	// client := NewGameClient(conn)
	client := gamev1connect.NewGameClient(conn)

	// Call the ListPlayers method
	response, err := client.ListPlayers(context.Background(), &playerv1.ListPlayersRequest{})
	if err != nil {
		t.Fatalf("Failed to call ListPlayers: %v", err)
	}

	// Handle the response
	for _, player := range response.Players {
		log.Printf("Player ID: %s, Name: %s", player.Id, player.Name)
	}
}
