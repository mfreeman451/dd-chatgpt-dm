// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "game.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Coordinates
 */
export interface Coordinates {
    /**
     * @generated from protobuf field: int32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message Player
 */
export interface Player {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string discord = 2;
     */
    discord: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string race = 4;
     */
    race: string;
    /**
     * @generated from protobuf field: string class = 5;
     */
    class: string;
    /**
     * @generated from protobuf field: int32 level = 6;
     */
    level: number;
    /**
     * @generated from protobuf field: string alignment = 7;
     */
    alignment: string;
    /**
     * @generated from protobuf field: string background = 8;
     */
    background: string;
    /**
     * @generated from protobuf field: int32 strength = 9;
     */
    strength: number;
    /**
     * @generated from protobuf field: int32 dexterity = 10;
     */
    dexterity: number;
    /**
     * @generated from protobuf field: int32 constitution = 11;
     */
    constitution: number;
    /**
     * @generated from protobuf field: int32 intelligence = 12;
     */
    intelligence: number;
    /**
     * @generated from protobuf field: int32 wisdom = 13;
     */
    wisdom: number;
    /**
     * @generated from protobuf field: int32 charisma = 14;
     */
    charisma: number;
    /**
     * @generated from protobuf field: int32 hitPoints = 15;
     */
    hitPoints: number;
    /**
     * @generated from protobuf field: int32 temporaryHitPoints = 16;
     */
    temporaryHitPoints: number;
    /**
     * @generated from protobuf field: int32 maxHitPoints = 17;
     */
    maxHitPoints: number;
    /**
     * @generated from protobuf field: int32 armorClass = 18;
     */
    armorClass: number;
    /**
     * @generated from protobuf field: int32 proficiencyBonus = 19;
     */
    proficiencyBonus: number;
    /**
     * @generated from protobuf field: repeated Skill skills = 20;
     */
    skills: Skill[];
    /**
     * @generated from protobuf field: repeated SavingThrow savingThrows = 21;
     */
    savingThrows: SavingThrow[];
    /**
     * @generated from protobuf field: repeated Language languages = 22;
     */
    languages: Language[];
    /**
     * @generated from protobuf field: repeated Equipment equipment = 23;
     */
    equipment: Equipment[];
    /**
     * @generated from protobuf field: repeated Feature features = 24;
     */
    features: Feature[];
    /**
     * @generated from protobuf field: repeated Spell spells = 25;
     */
    spells: Spell[];
    /**
     * @generated from protobuf field: int32 spellSlots = 26;
     */
    spellSlots: number;
    /**
     * @generated from protobuf field: int32 currentSpellSlots = 27;
     */
    currentSpellSlots: number;
    /**
     * @generated from protobuf field: int32 experiencePoints = 28;
     */
    experiencePoints: number;
    /**
     * @generated from protobuf field: int32 initiative = 29;
     */
    initiative: number;
    /**
     * @generated from protobuf field: int32 speed = 30;
     */
    speed: number;
    /**
     * @generated from protobuf field: string hitDice = 31;
     */
    hitDice: string;
    /**
     * @generated from protobuf field: DeathSaves deathSaves = 32;
     */
    deathSaves?: DeathSaves;
    /**
     * @generated from protobuf field: repeated AbilityScoreBonus abilityScoreBonuses = 33;
     */
    abilityScoreBonuses: AbilityScoreBonus[];
    /**
     * @generated from protobuf field: repeated SpecialAbility specialAbilities = 34;
     */
    specialAbilities: SpecialAbility[];
    /**
     * @generated from protobuf field: RacialTraits racialTraits = 35;
     */
    racialTraits?: RacialTraits;
    /**
     * @generated from protobuf field: Coordinates location = 36;
     */
    location?: Coordinates;
    /**
     * @generated from protobuf field: string LastLogin = 37 [json_name = "LastLogin"];
     */
    lastLogin: string;
    /**
     * @generated from protobuf field: string LastLogout = 38 [json_name = "LastLogout"];
     */
    lastLogout: string;
}
/**
 * @generated from protobuf message Skill
 */
export interface Skill {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message SavingThrow
 */
export interface SavingThrow {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message Language
 */
export interface Language {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message Equipment
 */
export interface Equipment {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message Feature
 */
export interface Feature {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message Spell
 */
export interface Spell {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message SpecialAbility
 */
export interface SpecialAbility {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message AbilityScoreBonus
 */
export interface AbilityScoreBonus {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message DeathSaves
 */
export interface DeathSaves {
    /**
     * @generated from protobuf field: int32 successes = 1;
     */
    successes: number;
    /**
     * @generated from protobuf field: int32 failures = 2;
     */
    failures: number;
}
/**
 * @generated from protobuf message RacialTraits
 */
export interface RacialTraits {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: int32 darkvision = 3;
     */
    darkvision: number;
    /**
     * @generated from protobuf field: string size = 4;
     */
    size: string;
    /**
     * @generated from protobuf field: int32 speed = 5;
     */
    speed: number;
    /**
     * @generated from protobuf field: repeated Language languages = 6;
     */
    languages: Language[];
    /**
     * @generated from protobuf field: int32 abilityScoreBonuses = 7;
     */
    abilityScoreBonuses: number;
    /**
     * @generated from protobuf field: repeated SpecialAbility specialAbilities = 8;
     */
    specialAbilities: SpecialAbility[];
}
/**
 * @generated from protobuf message Location
 */
export interface Location {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: repeated Item items = 3;
     */
    items: Item[];
    /**
     * @generated from protobuf field: repeated NPC npcs = 4;
     */
    npcs: NPC[];
}
/**
 * @generated from protobuf message Item
 */
export interface Item {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message NPC
 */
export interface NPC {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message CreatePlayerRequest
 */
export interface CreatePlayerRequest {
    /**
     * @generated from protobuf field: Player player = 2;
     */
    player?: Player;
}
/**
 * @generated from protobuf message CreatePlayerResponse
 */
export interface CreatePlayerResponse {
    /**
     * @generated from protobuf field: Player player = 1;
     */
    player?: Player;
}
/**
 * @generated from protobuf message MovePlayerRequest
 */
export interface MovePlayerRequest {
    /**
     * @generated from protobuf field: string player_id = 1;
     */
    playerId: string;
    /**
     * @generated from protobuf field: Coordinates new_location = 2;
     */
    newLocation?: Coordinates;
}
/**
 * @generated from protobuf message MovePlayerResponse
 */
export interface MovePlayerResponse {
    /**
     * @generated from protobuf field: Player player = 1;
     */
    player?: Player;
}
/**
 * @generated from protobuf message GetLocationRequest
 */
export interface GetLocationRequest {
    /**
     * @generated from protobuf field: Coordinates coordinates = 1;
     */
    coordinates?: Coordinates;
}
/**
 * @generated from protobuf message GetLocationResponse
 */
export interface GetLocationResponse {
    /**
     * @generated from protobuf field: Location location = 1;
     */
    location?: Location;
}
/**
 * @generated from protobuf message ListPlayersRequest
 */
export interface ListPlayersRequest {
}
/**
 * @generated from protobuf message ListPlayersResponse
 */
export interface ListPlayersResponse {
    /**
     * @generated from protobuf field: repeated Player players = 1;
     */
    players: Player[];
}
/**
 * @generated from protobuf message GetPlayerRequest
 */
export interface GetPlayerRequest {
    /**
     * @generated from protobuf field: string playerId = 1;
     */
    playerId: string; // Add the field to specify the player ID
}
/**
 * @generated from protobuf message GetPlayerResponse
 */
export interface GetPlayerResponse {
    /**
     * @generated from protobuf field: Player player = 1;
     */
    player?: Player; // Add the field to return the player
}
/**
 * @generated from protobuf message SetPlayerRequest
 */
export interface SetPlayerRequest {
    /**
     * @generated from protobuf field: Player player = 1;
     */
    player?: Player; // Add the field to specify the player
}
/**
 * @generated from protobuf message SetPlayerResponse
 */
export interface SetPlayerResponse {
    /**
     * @generated from protobuf field: Player player = 1;
     */
    player?: Player; // Add the field to return the player
}
/**
 * Added message
 *
 * @generated from protobuf message UpdatePlayerRequest
 */
export interface UpdatePlayerRequest {
    /**
     * @generated from protobuf field: string player_id = 1;
     */
    playerId: string;
    /**
     * @generated from protobuf field: Player player = 2;
     */
    player?: Player;
}
/**
 * Added message
 *
 * @generated from protobuf message UpdatePlayerResponse
 */
export interface UpdatePlayerResponse {
    /**
     * @generated from protobuf field: Player player = 1;
     */
    player?: Player;
}
// @generated message type with reflection information, may provide speed optimized methods
class Coordinates$Type extends MessageType<Coordinates> {
    constructor() {
        super("Coordinates", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "z", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Coordinates>): Coordinates {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Coordinates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coordinates): Coordinates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                case /* int32 z */ 3:
                    message.z = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coordinates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        /* int32 z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Varint).int32(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Coordinates
 */
export const Coordinates = new Coordinates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType<Player> {
    constructor() {
        super("Player", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "discord", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "race", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "alignment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "background", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "strength", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "dexterity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "constitution", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "intelligence", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "wisdom", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "charisma", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "hitPoints", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "temporaryHitPoints", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "maxHitPoints", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "armorClass", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "proficiencyBonus", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "skills", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Skill },
            { no: 21, name: "savingThrows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SavingThrow },
            { no: 22, name: "languages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Language },
            { no: 23, name: "equipment", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Equipment },
            { no: 24, name: "features", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Feature },
            { no: 25, name: "spells", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Spell },
            { no: 26, name: "spellSlots", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "currentSpellSlots", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "experiencePoints", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "initiative", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "speed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "hitDice", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "deathSaves", kind: "message", T: () => DeathSaves },
            { no: 33, name: "abilityScoreBonuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityScoreBonus },
            { no: 34, name: "specialAbilities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SpecialAbility },
            { no: 35, name: "racialTraits", kind: "message", T: () => RacialTraits },
            { no: 36, name: "location", kind: "message", T: () => Coordinates },
            { no: 37, name: "LastLogin", kind: "scalar", jsonName: "LastLogin", T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "LastLogout", kind: "scalar", jsonName: "LastLogout", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = { id: "", discord: "", name: "", race: "", class: "", level: 0, alignment: "", background: "", strength: 0, dexterity: 0, constitution: 0, intelligence: 0, wisdom: 0, charisma: 0, hitPoints: 0, temporaryHitPoints: 0, maxHitPoints: 0, armorClass: 0, proficiencyBonus: 0, skills: [], savingThrows: [], languages: [], equipment: [], features: [], spells: [], spellSlots: 0, currentSpellSlots: 0, experiencePoints: 0, initiative: 0, speed: 0, hitDice: "", abilityScoreBonuses: [], specialAbilities: [], lastLogin: "", lastLogout: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string discord */ 2:
                    message.discord = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string race */ 4:
                    message.race = reader.string();
                    break;
                case /* string class */ 5:
                    message.class = reader.string();
                    break;
                case /* int32 level */ 6:
                    message.level = reader.int32();
                    break;
                case /* string alignment */ 7:
                    message.alignment = reader.string();
                    break;
                case /* string background */ 8:
                    message.background = reader.string();
                    break;
                case /* int32 strength */ 9:
                    message.strength = reader.int32();
                    break;
                case /* int32 dexterity */ 10:
                    message.dexterity = reader.int32();
                    break;
                case /* int32 constitution */ 11:
                    message.constitution = reader.int32();
                    break;
                case /* int32 intelligence */ 12:
                    message.intelligence = reader.int32();
                    break;
                case /* int32 wisdom */ 13:
                    message.wisdom = reader.int32();
                    break;
                case /* int32 charisma */ 14:
                    message.charisma = reader.int32();
                    break;
                case /* int32 hitPoints */ 15:
                    message.hitPoints = reader.int32();
                    break;
                case /* int32 temporaryHitPoints */ 16:
                    message.temporaryHitPoints = reader.int32();
                    break;
                case /* int32 maxHitPoints */ 17:
                    message.maxHitPoints = reader.int32();
                    break;
                case /* int32 armorClass */ 18:
                    message.armorClass = reader.int32();
                    break;
                case /* int32 proficiencyBonus */ 19:
                    message.proficiencyBonus = reader.int32();
                    break;
                case /* repeated Skill skills */ 20:
                    message.skills.push(Skill.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated SavingThrow savingThrows */ 21:
                    message.savingThrows.push(SavingThrow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Language languages */ 22:
                    message.languages.push(Language.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Equipment equipment */ 23:
                    message.equipment.push(Equipment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Feature features */ 24:
                    message.features.push(Feature.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Spell spells */ 25:
                    message.spells.push(Spell.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 spellSlots */ 26:
                    message.spellSlots = reader.int32();
                    break;
                case /* int32 currentSpellSlots */ 27:
                    message.currentSpellSlots = reader.int32();
                    break;
                case /* int32 experiencePoints */ 28:
                    message.experiencePoints = reader.int32();
                    break;
                case /* int32 initiative */ 29:
                    message.initiative = reader.int32();
                    break;
                case /* int32 speed */ 30:
                    message.speed = reader.int32();
                    break;
                case /* string hitDice */ 31:
                    message.hitDice = reader.string();
                    break;
                case /* DeathSaves deathSaves */ 32:
                    message.deathSaves = DeathSaves.internalBinaryRead(reader, reader.uint32(), options, message.deathSaves);
                    break;
                case /* repeated AbilityScoreBonus abilityScoreBonuses */ 33:
                    message.abilityScoreBonuses.push(AbilityScoreBonus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated SpecialAbility specialAbilities */ 34:
                    message.specialAbilities.push(SpecialAbility.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* RacialTraits racialTraits */ 35:
                    message.racialTraits = RacialTraits.internalBinaryRead(reader, reader.uint32(), options, message.racialTraits);
                    break;
                case /* Coordinates location */ 36:
                    message.location = Coordinates.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* string LastLogin = 37 [json_name = "LastLogin"];*/ 37:
                    message.lastLogin = reader.string();
                    break;
                case /* string LastLogout = 38 [json_name = "LastLogout"];*/ 38:
                    message.lastLogout = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string discord = 2; */
        if (message.discord !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.discord);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string race = 4; */
        if (message.race !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.race);
        /* string class = 5; */
        if (message.class !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.class);
        /* int32 level = 6; */
        if (message.level !== 0)
            writer.tag(6, WireType.Varint).int32(message.level);
        /* string alignment = 7; */
        if (message.alignment !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.alignment);
        /* string background = 8; */
        if (message.background !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.background);
        /* int32 strength = 9; */
        if (message.strength !== 0)
            writer.tag(9, WireType.Varint).int32(message.strength);
        /* int32 dexterity = 10; */
        if (message.dexterity !== 0)
            writer.tag(10, WireType.Varint).int32(message.dexterity);
        /* int32 constitution = 11; */
        if (message.constitution !== 0)
            writer.tag(11, WireType.Varint).int32(message.constitution);
        /* int32 intelligence = 12; */
        if (message.intelligence !== 0)
            writer.tag(12, WireType.Varint).int32(message.intelligence);
        /* int32 wisdom = 13; */
        if (message.wisdom !== 0)
            writer.tag(13, WireType.Varint).int32(message.wisdom);
        /* int32 charisma = 14; */
        if (message.charisma !== 0)
            writer.tag(14, WireType.Varint).int32(message.charisma);
        /* int32 hitPoints = 15; */
        if (message.hitPoints !== 0)
            writer.tag(15, WireType.Varint).int32(message.hitPoints);
        /* int32 temporaryHitPoints = 16; */
        if (message.temporaryHitPoints !== 0)
            writer.tag(16, WireType.Varint).int32(message.temporaryHitPoints);
        /* int32 maxHitPoints = 17; */
        if (message.maxHitPoints !== 0)
            writer.tag(17, WireType.Varint).int32(message.maxHitPoints);
        /* int32 armorClass = 18; */
        if (message.armorClass !== 0)
            writer.tag(18, WireType.Varint).int32(message.armorClass);
        /* int32 proficiencyBonus = 19; */
        if (message.proficiencyBonus !== 0)
            writer.tag(19, WireType.Varint).int32(message.proficiencyBonus);
        /* repeated Skill skills = 20; */
        for (let i = 0; i < message.skills.length; i++)
            Skill.internalBinaryWrite(message.skills[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated SavingThrow savingThrows = 21; */
        for (let i = 0; i < message.savingThrows.length; i++)
            SavingThrow.internalBinaryWrite(message.savingThrows[i], writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* repeated Language languages = 22; */
        for (let i = 0; i < message.languages.length; i++)
            Language.internalBinaryWrite(message.languages[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* repeated Equipment equipment = 23; */
        for (let i = 0; i < message.equipment.length; i++)
            Equipment.internalBinaryWrite(message.equipment[i], writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* repeated Feature features = 24; */
        for (let i = 0; i < message.features.length; i++)
            Feature.internalBinaryWrite(message.features[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* repeated Spell spells = 25; */
        for (let i = 0; i < message.spells.length; i++)
            Spell.internalBinaryWrite(message.spells[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* int32 spellSlots = 26; */
        if (message.spellSlots !== 0)
            writer.tag(26, WireType.Varint).int32(message.spellSlots);
        /* int32 currentSpellSlots = 27; */
        if (message.currentSpellSlots !== 0)
            writer.tag(27, WireType.Varint).int32(message.currentSpellSlots);
        /* int32 experiencePoints = 28; */
        if (message.experiencePoints !== 0)
            writer.tag(28, WireType.Varint).int32(message.experiencePoints);
        /* int32 initiative = 29; */
        if (message.initiative !== 0)
            writer.tag(29, WireType.Varint).int32(message.initiative);
        /* int32 speed = 30; */
        if (message.speed !== 0)
            writer.tag(30, WireType.Varint).int32(message.speed);
        /* string hitDice = 31; */
        if (message.hitDice !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.hitDice);
        /* DeathSaves deathSaves = 32; */
        if (message.deathSaves)
            DeathSaves.internalBinaryWrite(message.deathSaves, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* repeated AbilityScoreBonus abilityScoreBonuses = 33; */
        for (let i = 0; i < message.abilityScoreBonuses.length; i++)
            AbilityScoreBonus.internalBinaryWrite(message.abilityScoreBonuses[i], writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* repeated SpecialAbility specialAbilities = 34; */
        for (let i = 0; i < message.specialAbilities.length; i++)
            SpecialAbility.internalBinaryWrite(message.specialAbilities[i], writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* RacialTraits racialTraits = 35; */
        if (message.racialTraits)
            RacialTraits.internalBinaryWrite(message.racialTraits, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* Coordinates location = 36; */
        if (message.location)
            Coordinates.internalBinaryWrite(message.location, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* string LastLogin = 37 [json_name = "LastLogin"]; */
        if (message.lastLogin !== "")
            writer.tag(37, WireType.LengthDelimited).string(message.lastLogin);
        /* string LastLogout = 38 [json_name = "LastLogout"]; */
        if (message.lastLogout !== "")
            writer.tag(38, WireType.LengthDelimited).string(message.lastLogout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Skill$Type extends MessageType<Skill> {
    constructor() {
        super("Skill", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Skill>): Skill {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Skill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Skill): Skill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Skill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Skill
 */
export const Skill = new Skill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SavingThrow$Type extends MessageType<SavingThrow> {
    constructor() {
        super("SavingThrow", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SavingThrow>): SavingThrow {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SavingThrow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SavingThrow): SavingThrow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SavingThrow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SavingThrow
 */
export const SavingThrow = new SavingThrow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Language$Type extends MessageType<Language> {
    constructor() {
        super("Language", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Language>): Language {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Language>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Language): Language {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Language, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Language
 */
export const Language = new Language$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Equipment$Type extends MessageType<Equipment> {
    constructor() {
        super("Equipment", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Equipment>): Equipment {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Equipment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Equipment): Equipment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Equipment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Equipment
 */
export const Equipment = new Equipment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Feature$Type extends MessageType<Feature> {
    constructor() {
        super("Feature", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Feature>): Feature {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Feature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Feature): Feature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Feature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Feature
 */
export const Feature = new Feature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Spell$Type extends MessageType<Spell> {
    constructor() {
        super("Spell", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Spell>): Spell {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Spell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Spell): Spell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Spell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Spell
 */
export const Spell = new Spell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecialAbility$Type extends MessageType<SpecialAbility> {
    constructor() {
        super("SpecialAbility", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpecialAbility>): SpecialAbility {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpecialAbility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpecialAbility): SpecialAbility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpecialAbility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SpecialAbility
 */
export const SpecialAbility = new SpecialAbility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityScoreBonus$Type extends MessageType<AbilityScoreBonus> {
    constructor() {
        super("AbilityScoreBonus", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityScoreBonus>): AbilityScoreBonus {
        const message = { name: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityScoreBonus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityScoreBonus): AbilityScoreBonus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityScoreBonus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityScoreBonus
 */
export const AbilityScoreBonus = new AbilityScoreBonus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeathSaves$Type extends MessageType<DeathSaves> {
    constructor() {
        super("DeathSaves", [
            { no: 1, name: "successes", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "failures", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeathSaves>): DeathSaves {
        const message = { successes: 0, failures: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeathSaves>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeathSaves): DeathSaves {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 successes */ 1:
                    message.successes = reader.int32();
                    break;
                case /* int32 failures */ 2:
                    message.failures = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeathSaves, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 successes = 1; */
        if (message.successes !== 0)
            writer.tag(1, WireType.Varint).int32(message.successes);
        /* int32 failures = 2; */
        if (message.failures !== 0)
            writer.tag(2, WireType.Varint).int32(message.failures);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeathSaves
 */
export const DeathSaves = new DeathSaves$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RacialTraits$Type extends MessageType<RacialTraits> {
    constructor() {
        super("RacialTraits", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "darkvision", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "speed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "languages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Language },
            { no: 7, name: "abilityScoreBonuses", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "specialAbilities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SpecialAbility }
        ]);
    }
    create(value?: PartialMessage<RacialTraits>): RacialTraits {
        const message = { name: "", description: "", darkvision: 0, size: "", speed: 0, languages: [], abilityScoreBonuses: 0, specialAbilities: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RacialTraits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RacialTraits): RacialTraits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* int32 darkvision */ 3:
                    message.darkvision = reader.int32();
                    break;
                case /* string size */ 4:
                    message.size = reader.string();
                    break;
                case /* int32 speed */ 5:
                    message.speed = reader.int32();
                    break;
                case /* repeated Language languages */ 6:
                    message.languages.push(Language.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 abilityScoreBonuses */ 7:
                    message.abilityScoreBonuses = reader.int32();
                    break;
                case /* repeated SpecialAbility specialAbilities */ 8:
                    message.specialAbilities.push(SpecialAbility.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RacialTraits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* int32 darkvision = 3; */
        if (message.darkvision !== 0)
            writer.tag(3, WireType.Varint).int32(message.darkvision);
        /* string size = 4; */
        if (message.size !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.size);
        /* int32 speed = 5; */
        if (message.speed !== 0)
            writer.tag(5, WireType.Varint).int32(message.speed);
        /* repeated Language languages = 6; */
        for (let i = 0; i < message.languages.length; i++)
            Language.internalBinaryWrite(message.languages[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int32 abilityScoreBonuses = 7; */
        if (message.abilityScoreBonuses !== 0)
            writer.tag(7, WireType.Varint).int32(message.abilityScoreBonuses);
        /* repeated SpecialAbility specialAbilities = 8; */
        for (let i = 0; i < message.specialAbilities.length; i++)
            SpecialAbility.internalBinaryWrite(message.specialAbilities[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RacialTraits
 */
export const RacialTraits = new RacialTraits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
    constructor() {
        super("Location", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Item },
            { no: 4, name: "npcs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NPC }
        ]);
    }
    create(value?: PartialMessage<Location>): Location {
        const message = { id: "", description: "", items: [], npcs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Location): Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated Item items */ 3:
                    message.items.push(Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated NPC npcs */ 4:
                    message.npcs.push(NPC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated Item items = 3; */
        for (let i = 0; i < message.items.length; i++)
            Item.internalBinaryWrite(message.items[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated NPC npcs = 4; */
        for (let i = 0; i < message.npcs.length; i++)
            NPC.internalBinaryWrite(message.npcs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Location
 */
export const Location = new Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Item$Type extends MessageType<Item> {
    constructor() {
        super("Item", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Item>): Item {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Item): Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Item
 */
export const Item = new Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NPC$Type extends MessageType<NPC> {
    constructor() {
        super("NPC", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NPC>): NPC {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NPC): NPC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NPC
 */
export const NPC = new NPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePlayerRequest$Type extends MessageType<CreatePlayerRequest> {
    constructor() {
        super("CreatePlayerRequest", [
            { no: 2, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<CreatePlayerRequest>): CreatePlayerRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatePlayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePlayerRequest): CreatePlayerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 2:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePlayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 2; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreatePlayerRequest
 */
export const CreatePlayerRequest = new CreatePlayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePlayerResponse$Type extends MessageType<CreatePlayerResponse> {
    constructor() {
        super("CreatePlayerResponse", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<CreatePlayerResponse>): CreatePlayerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatePlayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePlayerResponse): CreatePlayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePlayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreatePlayerResponse
 */
export const CreatePlayerResponse = new CreatePlayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovePlayerRequest$Type extends MessageType<MovePlayerRequest> {
    constructor() {
        super("MovePlayerRequest", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "new_location", kind: "message", T: () => Coordinates }
        ]);
    }
    create(value?: PartialMessage<MovePlayerRequest>): MovePlayerRequest {
        const message = { playerId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MovePlayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MovePlayerRequest): MovePlayerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                case /* Coordinates new_location */ 2:
                    message.newLocation = Coordinates.internalBinaryRead(reader, reader.uint32(), options, message.newLocation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MovePlayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        /* Coordinates new_location = 2; */
        if (message.newLocation)
            Coordinates.internalBinaryWrite(message.newLocation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MovePlayerRequest
 */
export const MovePlayerRequest = new MovePlayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovePlayerResponse$Type extends MessageType<MovePlayerResponse> {
    constructor() {
        super("MovePlayerResponse", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<MovePlayerResponse>): MovePlayerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MovePlayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MovePlayerResponse): MovePlayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MovePlayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MovePlayerResponse
 */
export const MovePlayerResponse = new MovePlayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLocationRequest$Type extends MessageType<GetLocationRequest> {
    constructor() {
        super("GetLocationRequest", [
            { no: 1, name: "coordinates", kind: "message", T: () => Coordinates }
        ]);
    }
    create(value?: PartialMessage<GetLocationRequest>): GetLocationRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLocationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLocationRequest): GetLocationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Coordinates coordinates */ 1:
                    message.coordinates = Coordinates.internalBinaryRead(reader, reader.uint32(), options, message.coordinates);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLocationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Coordinates coordinates = 1; */
        if (message.coordinates)
            Coordinates.internalBinaryWrite(message.coordinates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetLocationRequest
 */
export const GetLocationRequest = new GetLocationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLocationResponse$Type extends MessageType<GetLocationResponse> {
    constructor() {
        super("GetLocationResponse", [
            { no: 1, name: "location", kind: "message", T: () => Location }
        ]);
    }
    create(value?: PartialMessage<GetLocationResponse>): GetLocationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLocationResponse): GetLocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Location location */ 1:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Location location = 1; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetLocationResponse
 */
export const GetLocationResponse = new GetLocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPlayersRequest$Type extends MessageType<ListPlayersRequest> {
    constructor() {
        super("ListPlayersRequest", []);
    }
    create(value?: PartialMessage<ListPlayersRequest>): ListPlayersRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPlayersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlayersRequest): ListPlayersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListPlayersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListPlayersRequest
 */
export const ListPlayersRequest = new ListPlayersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPlayersResponse$Type extends MessageType<ListPlayersResponse> {
    constructor() {
        super("ListPlayersResponse", [
            { no: 1, name: "players", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Player }
        ]);
    }
    create(value?: PartialMessage<ListPlayersResponse>): ListPlayersResponse {
        const message = { players: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListPlayersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlayersResponse): ListPlayersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Player players */ 1:
                    message.players.push(Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPlayersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Player players = 1; */
        for (let i = 0; i < message.players.length; i++)
            Player.internalBinaryWrite(message.players[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListPlayersResponse
 */
export const ListPlayersResponse = new ListPlayersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerRequest$Type extends MessageType<GetPlayerRequest> {
    constructor() {
        super("GetPlayerRequest", [
            { no: 1, name: "playerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPlayerRequest>): GetPlayerRequest {
        const message = { playerId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerRequest): GetPlayerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string playerId */ 1:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string playerId = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerRequest
 */
export const GetPlayerRequest = new GetPlayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerResponse$Type extends MessageType<GetPlayerResponse> {
    constructor() {
        super("GetPlayerResponse", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<GetPlayerResponse>): GetPlayerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerResponse): GetPlayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerResponse
 */
export const GetPlayerResponse = new GetPlayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerRequest$Type extends MessageType<SetPlayerRequest> {
    constructor() {
        super("SetPlayerRequest", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<SetPlayerRequest>): SetPlayerRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerRequest): SetPlayerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerRequest
 */
export const SetPlayerRequest = new SetPlayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerResponse$Type extends MessageType<SetPlayerResponse> {
    constructor() {
        super("SetPlayerResponse", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<SetPlayerResponse>): SetPlayerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerResponse): SetPlayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerResponse
 */
export const SetPlayerResponse = new SetPlayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePlayerRequest$Type extends MessageType<UpdatePlayerRequest> {
    constructor() {
        super("UpdatePlayerRequest", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<UpdatePlayerRequest>): UpdatePlayerRequest {
        const message = { playerId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePlayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePlayerRequest): UpdatePlayerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                case /* Player player */ 2:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePlayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        /* Player player = 2; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdatePlayerRequest
 */
export const UpdatePlayerRequest = new UpdatePlayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePlayerResponse$Type extends MessageType<UpdatePlayerResponse> {
    constructor() {
        super("UpdatePlayerResponse", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<UpdatePlayerResponse>): UpdatePlayerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePlayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePlayerResponse): UpdatePlayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePlayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdatePlayerResponse
 */
export const UpdatePlayerResponse = new UpdatePlayerResponse$Type();
/**
 * @generated ServiceType for protobuf service Game
 */
export const Game = new ServiceType("Game", [
    { name: "CreatePlayer", options: {}, I: CreatePlayerRequest, O: CreatePlayerResponse },
    { name: "MovePlayer", options: {}, I: MovePlayerRequest, O: MovePlayerResponse },
    { name: "GetLocation", options: {}, I: GetLocationRequest, O: GetLocationResponse },
    { name: "ListPlayers", options: {}, I: ListPlayersRequest, O: ListPlayersResponse },
    { name: "GetPlayer", options: {}, I: GetPlayerRequest, O: GetPlayerResponse },
    { name: "SetPlayer", options: {}, I: SetPlayerRequest, O: SetPlayerResponse },
    { name: "UpdatePlayer", options: {}, I: UpdatePlayerRequest, O: UpdatePlayerResponse }
]);
